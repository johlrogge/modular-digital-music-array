---- Cargo.toml
[workspace]
members = [
    # Components (bricks)
    "components/clock",
    "components/time_primitives",
    "components/playback_primitives",
    "components/media_downloader",
    "components/media_client",
    "components/playback_engine",
    
    # Bases (entry points)
    "bases/download_cli",
    "bases/media_ctl"
]
resolver = "2"
[workspace.package]
version = "0.1.0"
edition = "2021"
authors = ["MDMA Development Team"]
repository = "https://github.com/your-org/mdma"
license = "MIT"

[workspace.dependencies]
tokio = { version = "1.36", features = ["full"] }
tracing = "0.1"
color-eyre = "0.6"
thiserror = "1.0"
parking_lot = "0.12"
assert_matches = "1.5"

---- configuration.nix
# Edit this configuration file to define what should be installed on
# your system. Help is available in the configuration.nix(5) man page
# and in the NixOS manual (accessible by running 'nixos-help').

{ config, pkgs, ... }:

{
  # System Configuration
  system.stateVersion = "23.11"; # Please read the documentation before changing

  # Hardware Configuration will be provided by nixos-hardware module

  # Sound Configuration
  sound.enable = true;

  # Boot Configuration
  boot = {
    loader = {
      generic-extlinux-compatible.enable = true;
      raspberryPi = {
        enable = true;
        version = 5;
      };
    };
    
    # Kernel Parameters
    kernelParams = [
      "console=ttyAMA0,115200"
      "console=tty1"
      # Audio related tweaks
      "threadirqs"
      "isolcpus=3" # Isolate last CPU core for audio processing
    ];
    
    # Kernel Modules
    kernelModules = [ "snd-usb-audio" ];
  };

  # Storage Configuration
  fileSystems = {
    "/" = {
      device = "/dev/disk/by-label/NIXOS_SD";
      fsType = "ext4";
      options = [ "noatime" "nodiratime" ];
    };
    
    "/boot" = {
      device = "/dev/disk/by-label/NIXOS_BOOT";
      fsType = "vfat";
    };
    
    "/data/music" = {
      device = "/dev/disk/by-label/MUSIC_LIB";
      fsType = "ext4";
      options = [ "noatime" "nodiratime" ];
    };
    
    "/data/cache" = {
      device = "/dev/disk/by-label/MUSIC_CACHE";
      fsType = "ext4";
      options = [ "noatime" "nodiratime" ];
    };
    
    "/data/backups" = {
      device = "/dev/disk/by-label/MUSIC_BACKUP";
      fsType = "ext4";
      options = [ "noatime" "nodiratime" ];
    };
  };

  # Networking
  networking = {
    hostName = "music-player";
    networkmanager.enable = true;
    firewall = {
      enable = true;
      allowedTCPPorts = [ 
        1780  # Snapcast control
        4953  # OSC timing
      ];
    };
  };

  # System Services
  services = {
    # PipeWire Configuration
    pipewire = {
      enable = true;
      alsa.enable = true;
      alsa.support32Bit = false;
      pulse.enable = true;
      
      # Basic PipeWire setup, configuration is in /etc/pipewire/pipewire.conf.d/
    };

    # Enable OpenSSH for remote management
    openssh.enable = true;
  };

  # System Packages
  environment.systemPackages = with pkgs; [
    # Audio utilities
    pipewire
    alsa-utils
    # System utilities
    vim
    git
    htop
    # Development tools
    rustup
  ];

  # User Configuration
  users.users.music = {
    isNormalUser = true;
    extraGroups = [ "audio" "pipewire" "networkmanager" "wheel" ];
    initialPassword = "changeme";
  };

  # System Optimization
  systemd = {
    # Optimize services for audio
    user.extraConfig = ''
      DefaultCPUAccounting=yes
      DefaultIOAccounting=yes
    '';
    services = {
      pipewire = {
        serviceConfig = {
          Nice = -11;
          IOSchedulingClass = "realtime";
          IOSchedulingPriority = 0;
          CPUSchedulingPolicy = "fifo";
          CPUSchedulingPriority = 99;
        };
      };
    };
  };

  # Performance Tuning
  boot.kernel.sysctl = {
    # IO optimizations
    "vm.swappiness" = 10;
    # Audio optimizations
    "fs.inotify.max_user_watches" = 524288;
    # Network optimizations
    "net.core.rmem_max" = 2500000;
    "net.core.wmem_max" = 2500000;
  };
}

---- flake.nix
{
  description = "Modular Distributed Music Array";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-24.11";
    flake-utils.url = "github:numtide/flake-utils";
    rust-overlay = {
      url = "github:oxalica/rust-overlay";
      inputs = {
        nixpkgs.follows = "nixpkgs";
        flake-utils.follows = "flake-utils";
      };
    };
    crane = {
      url = "github:ipetkov/crane";
      inputs = {
        nixpkgs.follows = "nixpkgs";
      };
    };
  };

  outputs = { self, nixpkgs, flake-utils, rust-overlay, crane }:
    let
      # System-specific outputs (packages, devShell)
      perSystem = flake-utils.lib.eachDefaultSystem (system:
        let
          overlays = [ (import rust-overlay) ];
          pkgs = import nixpkgs {
            inherit system overlays;
          };
          
          rustToolchain = pkgs.rust-bin.stable.latest.default;
          craneLib = (crane.mkLib pkgs).overrideToolchain rustToolchain;

          commonArgs = {
            src = craneLib.cleanCargoSource ./.;
            pname = "download-cli";
            version = "0.1.0";
            
            buildInputs = [];
            nativeBuildInputs = [ pkgs.pkg-config ];
          };

          cargoArtifacts = craneLib.buildDepsOnly commonArgs;

          download-cli = craneLib.buildPackage (commonArgs // {
            inherit cargoArtifacts;
          });

          download-cli-wrapped = pkgs.symlinkJoin {
            name = "download-cli";
            paths = [ download-cli ];
            buildInputs = [ pkgs.makeWrapper ];
            postBuild = ''
              wrapProgram $out/bin/download-cli \
                --prefix PATH : ${pkgs.lib.makeBinPath [ pkgs.yt-dlp ]}
            '';
          };
        in
        {
          packages = {
            inherit download-cli-wrapped;
            default = download-cli-wrapped;
          };

          devShells.default = pkgs.mkShell {
            packages = with pkgs; [
              rustToolchain
              yt-dlp
              pipewire
            ];
          };
        }
      );

      # NixOS configuration for the VM
      nixosConfig = { config, lib, pkgs, ... }: {
        imports = [
          ./configuration.nix  # Import the existing NixOS configuration
        ];

        # VM-specific settings
        virtualisation = {
          cores = 2;
          memorySize = 4096; # MB
          graphics = true;   # Enable graphical output
        };

        # Auto-start services
        systemd.services.mdma = {
          description = "Modular Distributed Music Array";
          wantedBy = [ "multi-user.target" ];
          after = [ "network.target" "pipewire.service" ];
          
          serviceConfig = {
            Type = "simple";
            User = "music";
            ExecStart = "${self.packages.${pkgs.system}.download-cli-wrapped}/bin/download-cli";
            Restart = "on-failure";
          };
        };
      };
    in
    {
      # Merge the per-system outputs
      inherit (perSystem) packages devShells;

      # Add NixOS configuration
      nixosConfigurations.default = nixpkgs.lib.nixosSystem {
        system = "x86_64-linux";  # You might want to make this configurable
        modules = [
          nixosConfig
        ];
      };
    };
}

---- bases/download_cli/Cargo.toml
[package]
name = "download-cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
media-downloader = { path = "../../components/media_downloader" }
tokio = { workspace = true, features = ["full"] }
color-eyre = { workspace = true }
clap = { version = "4.4", features = ["derive"] }

---- bases/download_cli/src/app.rs
// bases/download_cli/src/app.rs
use color_eyre::Result;
use media_downloader::MediaDownloader;
use crate::args::Args;
use crate::output::OutputHandler;

pub struct App {
    args: Args,
    output: OutputHandler,
}

impl App {
    pub fn new(args: Args) -> Self {
        let output = OutputHandler::new(args.verbose);
        Self { args, output }
    }

    pub async fn run(&self) -> Result<()> {
        self.output.print_download_start(&self.args.url);

        let downloader = MediaDownloader::new(&self.args.output_dir).await?;
        let (path, metadata) = downloader.download(&self.args.url).await?;

        self.output.print_download_complete(&path, &metadata);

        Ok(())
    }

    pub fn print_error(&self, error: &color_eyre::Report) {
        self.output.print_error(error);
    }
}

---- bases/download_cli/src/args.rs
// bases/download_cli/src/args.rs
use clap::Parser;
use std::path::PathBuf;

/// Download audio tracks from various sources
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
pub struct Args {
    /// Directory to store downloaded files
    #[arg(short, long)]
    pub output_dir: PathBuf,

    /// URL to download from
    pub url: String,

    /// Enable verbose output
    #[arg(short, long)]
    pub verbose: bool,
}

---- bases/download_cli/src/Cargo.toml
[package]
name = "download-cli"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
media-downloader = { path = "../../components/media_downloader" }
tokio = { workspace = true, features = ["full"] }
color-eyre = { workspace = true }
clap = { version = "4.4", features = ["derive"] }

---- bases/download_cli/src/main.rs
// bases/download_cli/src/main.rs
mod args;
mod output;
mod app;

use clap::Parser;
use color_eyre::Result;
use args::Args;
use app::App;

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;

    let args = Args::parse();
    let app = App::new(args);

    if let Err(error) = app.run().await {
        app.print_error(&error);
        std::process::exit(1);
    }
    Ok(())
}

---- bases/download_cli/src/output.rs
// bases/download_cli/src/output.rs
use std::path::Path;
use media_downloader::TrackMetadata;

pub struct OutputHandler {
    verbose: bool,
}

impl OutputHandler {
    pub fn new(verbose: bool) -> Self {
        Self { verbose }
    }

    pub fn print_download_start(&self, url: &str) {
        println!("Starting download from: {}", url);
    }

    pub fn print_download_complete(&self, path: &Path, metadata: &TrackMetadata) {
        println!("Downloaded: {} to {}", metadata.location.title, path.display());
        println!("Artist: {}", metadata.location.artist);
        
        if let Some(album) = &metadata.location.album {
            println!("Album: {}", album);
        }
        println!("Duration: {:.1} seconds", metadata.duration);
        
        if self.verbose {
            println!("Source: {}", metadata.source_url);
            println!("Download time: {}", metadata.download_time);
        }
    }

    pub fn print_error(&self, error: &color_eyre::Report) {
        eprintln!("Error: {}", error);
        
        if self.verbose {
            eprintln!("\nError details:");
            error.chain().skip(1).for_each(|cause| {
                eprintln!("  caused by: {}", cause);
            });
        }
    }
}

---- bases/media_ctl/Cargo.toml
[package]
name = "media-ctl"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
clap = { version = "4.4", features = ["derive"] }
color-eyre = { workspace = true }
tokio = { workspace = true, features = ["full"] }
nng = "1.0"
prost = "0.11"
anyhow = "1.0"
media-client = { path = "../../components/media_client" }

---- bases/media_ctl/src/commands.rs
use clap::Subcommand;
use color_eyre::Result;
use std::path::PathBuf;
use media_client::Channel;

#[derive(Subcommand)]
pub enum Commands {
    /// Load a track from the library
    Load {
        /// Path to music library
        #[arg(long)]
        library: PathBuf,
        
        /// Artist name
        #[arg(long)]
        artist: String,
        
        /// Album name (optional)
        #[arg(long)]
        album: Option<String>,
        
        /// Song name
        #[arg(long)]
        song: String,
        
        /// Channel (A or B)
        #[arg(long)]
        channel: char,
    },
    
    /// Play a loaded track
    Play {
        /// Channel (A or B)
        #[arg(long)]
        channel: char,
    },
    
    /// Stop a playing track
    Stop {
        /// Channel (A or B)
        #[arg(long)]
        channel: char,
    },
    
    /// Set volume for a channel
    Volume {
        /// Channel (A or B)
        #[arg(long)]
        channel: char,
        
        /// Volume in dB (-inf to 0)
        #[arg(long)]
        db: f32,
    },
}

pub fn parse_channel(c: char) -> Result<Channel> {
    match c.to_uppercase().next() {
        Some('A') => Ok(Channel::A),
        Some('B') => Ok(Channel::B),
        _ => Err(color_eyre::eyre::eyre!("Invalid channel. Use 'A' or 'B'"))
    }
}

pub fn channel_to_string(channel: Channel) -> &'static str {
    match channel {
        Channel::A => "A",
        Channel::B => "B",
    }
}

pub fn construct_path(library: PathBuf, artist: String, album: Option<String>, song: String) -> Result<PathBuf> {
    let mut path = library;
    path.push(artist);
    if let Some(album) = album {
        path.push(album);
    }
    path.push(format!("{}.flac", song));
    
    if !path.exists() {
        return Err(color_eyre::eyre::eyre!("Track not found: {}", path.display()));
    }
    
    Ok(path)
}
---- bases/media_ctl/src/main.rs
use clap::Parser;
use color_eyre::Result;
mod commands;

use commands::Commands;

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[tokio::main]
async fn main() -> Result<()> {
    color_eyre::install()?;
    let cli = Cli::parse();

    let client = media_client::MediaClient::connect("ipc:///tmp/mdma-commands")?;

    match cli.command {
        Commands::Load {
            library,
            artist,
            album,
            song,
            channel,
        } => {
            let channel = commands::parse_channel(channel)?;
            let path = commands::construct_path(library, artist, album, song)?;
            client.load_track(path, channel)?;
            println!(
                "Track loaded on channel {}",
                commands::channel_to_string(channel)
            );
        }

        Commands::Play { channel } => {
            let channel = commands::parse_channel(channel)?;
            client.play(channel)?;
            println!("Playing channel {}", commands::channel_to_string(channel));
        }

        Commands::Stop { channel } => {
            let channel = commands::parse_channel(channel)?;
            client.stop(channel)?;
            println!("Stopped channel {}", commands::channel_to_string(channel));
        }

        Commands::Volume { channel, db } => {
            let channel = commands::parse_channel(channel)?;
            client.set_volume(channel, db)?;
            println!(
                "Set volume of channel {} to {}dB",
                commands::channel_to_string(channel),
                db
            );
        }
    }

    Ok(())
}

---- components/clock/Cargo.toml
[package]
name = "clock"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
time-primitives = { path = "../time_primitives" }
playback-primitives = { path = "../playback_primitives" }
thiserror.workspace = true
parking_lot.workspace = true
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

[dev-dependencies]
assert_matches.workspace = true
---- components/clock/src/commands.rs
use playback_types::{Channel, PlaybackError, Volume};
use std::path::PathBuf;
use thiserror::Error;
use time_primitives::Ticks;
use time_primitives::TimeError;
use uuid::Uuid;

#[derive(Debug, Error)]
pub enum CommandError {
    #[error("Invalid timing")]
    Timing(#[from] TimeError),
    #[error("Track not found: {0}")]
    TrackNotFound(String),
    #[error("Channel error: {0}")]
    Channel(#[from] PlaybackError),
}

/// Unique identifier for a loaded track
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct TrackId(Uuid);

impl TrackId {
    pub fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

impl ToString for TrackId {
    fn to_string(&self) -> String {
        self.0.to_string()
    }
}

/// A single volume point in time
#[derive(Debug, Clone, Copy)]
pub struct VolumePoint {
    pub tick: Ticks,
    pub volume: Volume,
}

/// Command to control playback across the system
#[derive(Debug, Clone)]
pub enum Command {
    /// Load a track into memory but don't start playback
    LoadTrack {
        track_id: TrackId,
        path: PathBuf,
        channel: Channel,
    },

    /// Begin playback of a loaded track
    StartTrack {
        track_id: TrackId,
        start_position: Ticks,
        initial_volume: Volume,
    },

    /// Stop playback on a channel
    StopChannel(Channel),

    /// Set a volume point for a channel
    SetVolumePoint {
        channel: Channel,
        point: VolumePoint,
    },
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_volume_control() -> Result<(), CommandError> {
        // Simulate fader movement sampled at regular intervals
        let fader_movement = vec![
            VolumePoint {
                tick: Ticks::new(0),
                volume: Volume::new(0.0)?, // Unity gain
            },
            VolumePoint {
                tick: Ticks::new(480),      // Half a beat later
                volume: Volume::new(-3.0)?, // -3dB
            },
            VolumePoint {
                tick: Ticks::new(960),      // One beat later
                volume: Volume::new(-6.0)?, // -6dB
            },
            VolumePoint {
                tick: Ticks::new(1920), // Two beats later
                volume: Volume::SILENT, // Silent
            },
        ];

        // In practice, these would be sent as individual commands as the
        // fader is moved, capturing the actual performance
        let commands: Vec<Command> = fader_movement
            .into_iter()
            .map(|point| Command::SetVolumePoint {
                channel: Channel::CHANNEL_A,
                point,
            })
            .collect();

        assert_eq!(commands.len(), 4);
        Ok(())
    }
}

---- components/clock/src/lib.rs
use parking_lot::RwLock;
use std::sync::Arc;
use std::time::{Duration, Instant};
use thiserror::Error;

pub mod protocol;

#[derive(Debug, Error)]
pub enum ClockError {
    #[error("Invalid tick update")]
    InvalidTick,
}

pub trait TimeSource {
    fn now(&self) -> Instant;
}

#[derive(Clone)]
pub struct SystemTimeSource;

impl TimeSource for SystemTimeSource {
    fn now(&self) -> Instant {
        Instant::now()
    }
}

pub struct ClockState {
    ticks: u64,
    tempo: f64,
    last_tick_time: Instant,
}

impl ClockState {
    fn new(time_source: &dyn TimeSource) -> Self {
        Self {
            ticks: 0,
            tempo: 120.0,
            last_tick_time: time_source.now(),
        }
    }
}

pub struct MusicalClock<T: TimeSource> {
    state: Arc<RwLock<ClockState>>,
    time_source: T,
}

impl<T: TimeSource> MusicalClock<T> {
    pub fn new(time_source: T) -> Self {
        Self {
            state: Arc::new(RwLock::new(ClockState::new(&time_source))),
            time_source,
        }
    }

    pub fn tick(&self) -> Result<(), ClockError> {
        let mut state = self.state.write();
        state.ticks += 1;
        state.last_tick_time = self.time_source.now();
        Ok(())
    }

    pub fn set_tempo(&self, bpm: f64) -> Result<(), ClockError> {
        let mut state = self.state.write();
        state.tempo = bpm.clamp(20.0, 400.0);
        Ok(())
    }

    pub fn get_position(&self) -> (u64, f64) {
        let state = self.state.read();
        (state.ticks, state.tempo)
    }

    pub fn time_since_last_tick(&self) -> Duration {
        let state = self.state.read();
        self.time_source.now().duration_since(state.last_tick_time)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::atomic::{AtomicU64, Ordering};

    #[derive(Clone)]
    pub struct TimeSourceStub {
        current_time: Arc<AtomicU64>,
        start: Instant,
    }

    impl TimeSourceStub {
        pub fn new() -> Self {
            Self {
                current_time: Arc::new(AtomicU64::new(0)),
                start: Instant::now(),
            }
        }

        pub fn advance(&self, duration: Duration) {
            self.current_time
                .fetch_add(duration.as_nanos() as u64, Ordering::SeqCst);
        }
    }

    impl TimeSource for TimeSourceStub {
        fn now(&self) -> Instant {
            let nanos = self.current_time.load(Ordering::SeqCst);
            self.start + Duration::from_nanos(nanos)
        }
    }

    #[test]
    fn test_clock_creation() {
        let time_source = TimeSourceStub::new();
        let clock = MusicalClock::new(time_source);
        let (ticks, tempo) = clock.get_position();

        assert_eq!(ticks, 0);
        assert_eq!(tempo, 120.0);
    }

    #[test]
    fn test_tick_updates_time() {
        let time_source = TimeSourceStub::new();
        let clock = MusicalClock::new(time_source.clone());

        time_source.advance(Duration::from_millis(10));
        clock.tick().unwrap();

        assert_eq!(clock.time_since_last_tick().as_millis(), 0);

        time_source.advance(Duration::from_millis(5));
        assert_eq!(clock.time_since_last_tick().as_millis(), 5);
    }
}

---- components/clock/src/protocol.rs
use playback_primitives::{Channel, Volume};
use serde::{Deserialize, Serialize};
use time_primitives::Ticks;

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct FileRef(String);

impl FileRef {
    pub fn new(path: impl AsRef<str>) -> Self {
        Self(path.as_ref().to_owned())
    }
}

/// Protocol Messages
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum Message {
    /// Load a track into memory but don't start playback
    LoadTrack { file: FileRef, channel: Channel },

    /// Begin playback of a loaded track
    StartTrack {
        channel: Channel,
        start_position: Ticks,
        initial_volume: Volume,
    },

    /// Stop playback on a channel
    StopChannel(Channel),

    /// Set volume for a channel
    SetVolume {
        channel: Channel,
        tick: Ticks,
        volume: Volume,
    },

    /// Set mute state for a channel
    SetMute {
        channel: Channel,
        tick: Ticks,
        muted: bool,
    },
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_mute_sequence() {
        let sequence = vec![
            Message::SetMute {
                channel: Channel::CHANNEL_A,
                tick: Ticks::new(0),
                muted: true,
            },
            Message::SetVolume {
                channel: Channel::CHANNEL_A,
                tick: Ticks::new(0),
                volume: Volume::new(-6.0).unwrap(),
            },
            Message::SetMute {
                channel: Channel::CHANNEL_A,
                tick: Ticks::new(960),
                muted: false,
            },
        ];

        let json = serde_json::to_string(&sequence).unwrap();
        let decoded: Vec<Message> = serde_json::from_str(&json).unwrap();
        assert_eq!(sequence, decoded);
    }
}

---- components/media_client/Cargo.toml
[package]
name = "media-client"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
nng = "1.0"
tokio = { workspace = true, features = ["full"] }
thiserror = { workspace = true }
prost = "0.11"
bytes = "1.0"
async-trait = "0.1"
playback-engine = { path = "../playback_engine" }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

---- components/media_client/src/error.rs
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ClientError {
    #[error("Connection error: {0}")]
    Connection(String),

    #[error("Command failed: {0}")]
    Command(String),

    #[error("Protocol error: {0}")]
    Protocol(String),
}

---- components/media_client/src/lib.rs
mod error;
mod protocol;
mod types;

use error::ClientError;
use nng::{Protocol, Socket};
use protocol::{Command, Response};
use std::path::PathBuf;
pub use types::Channel;

pub struct MediaClient {
    socket: Socket,
}

impl MediaClient {
    pub fn connect(url: &str) -> Result<Self, ClientError> {
        let socket =
            Socket::new(Protocol::Req0).map_err(|e| ClientError::Connection(format!("{:?}", e)))?;

        socket
            .dial(url)
            .map_err(|e| ClientError::Connection(format!("{:?}", e)))?;

        Ok(Self { socket })
    }

    pub fn load_track(&self, path: PathBuf, channel: Channel) -> Result<(), ClientError> {
        let cmd = Command::LoadTrack { path, channel };
        self.send_command(cmd)
    }

    pub fn play(&self, channel: Channel) -> Result<(), ClientError> {
        let cmd = Command::Play { channel };
        self.send_command(cmd)
    }

    pub fn stop(&self, channel: Channel) -> Result<(), ClientError> {
        let cmd = Command::Stop { channel };
        self.send_command(cmd)
    }

    pub fn set_volume(&self, channel: Channel, db: f32) -> Result<(), ClientError> {
        let cmd = Command::SetVolume { channel, db };
        self.send_command(cmd)
    }

    fn send_command(&self, cmd: Command) -> Result<(), ClientError> {
        // Serialize command
        let data = serde_json::to_vec(&cmd).map_err(|e| ClientError::Protocol(e.to_string()))?;

        // Send command
        self.socket
            .send(&data)
            .map_err(|e| ClientError::Connection(format!("{:?}", e)))?;

        // Receive response
        let msg = self
            .socket
            .recv()
            .map_err(|e| ClientError::Connection(format!("{:?}", e)))?;

        // Convert to slice for deserialization
        let msg_slice = msg.as_slice();

        // Parse response
        let response: Response =
            serde_json::from_slice(msg_slice).map_err(|e| ClientError::Protocol(e.to_string()))?;

        if !response.success {
            return Err(ClientError::Command(response.error_message));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_channel_conversion() {
        assert_eq!(i32::from(Channel::A), 0);
        assert_eq!(i32::from(Channel::B), 1);

        assert!(matches!(Channel::try_from(0), Ok(Channel::A)));
        assert!(matches!(Channel::try_from(1), Ok(Channel::B)));
        assert!(Channel::try_from(2).is_err());
    }
}

---- components/media_client/src/protocol.rs
use crate::Channel;
use serde::{Deserialize, Serialize};
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum Command {
    LoadTrack { path: PathBuf, channel: Channel },
    Play { channel: Channel },
    Stop { channel: Channel },
    SetVolume { channel: Channel, db: f32 },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Response {
    pub success: bool,
    pub error_message: String,
}

---- components/media_client/src/types.rs
use crate::error::ClientError;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Channel {
    A,
    B,
}

impl TryFrom<i32> for Channel {
    type Error = ClientError;

    fn try_from(value: i32) -> Result<Self, Self::Error> {
        match value {
            0 => Ok(Channel::A),
            1 => Ok(Channel::B),
            _ => Err(ClientError::Protocol("Invalid channel value".into())),
        }
    }
}

impl From<Channel> for i32 {
    fn from(channel: Channel) -> Self {
        match channel {
            Channel::A => 0,
            Channel::B => 1,
        }
    }
}

---- components/media_downloader/Cargo.toml
[package]
name = "media-downloader"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
tokio = { workspace = true, features = ["full"] }
thiserror.workspace = true
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
url = "2.4"
sha2 = "0.10"
hex = "0.4"
tempfile = "3.8"
which = "4.4"
chrono = { version = "0.4", features = ["serde"] }
async-trait = "0.1"
dunce = "1.0"
sanitize-filename = "0.5"

[dev-dependencies]
assert_matches.workspace = true
tokio = { workspace = true, features = ["macros", "rt-multi-thread"] }

---- components/media_downloader/src/lib.rs
// components/media_downloader/src/lib.rs
mod organization;
mod types;
mod ytdlp;

use std::path::{Path, PathBuf};
use std::sync::Arc;
use tempfile::TempDir;
use tokio::fs;
use url::Url;

pub use crate::organization::TrackLocation;
pub use crate::types::{DownloadError, Downloader, TrackMetadata};
use crate::ytdlp::YtDlp;

pub struct MediaDownloader {
    download_path: PathBuf,
    temp_path: PathBuf,
    downloader: Arc<dyn Downloader + Send + Sync>,
}

impl MediaDownloader {
    pub async fn new(download_path: impl AsRef<Path>) -> Result<Self, DownloadError> {
        Self::new_with_downloader(download_path, Arc::new(YtDlp)).await
    }

    pub async fn new_with_downloader(
        download_path: impl AsRef<Path>,
        downloader: Arc<dyn Downloader + Send + Sync>,
    ) -> Result<Self, DownloadError> {
        downloader.check_available().await?;

        let download_path =
            dunce::canonicalize(download_path.as_ref()).map_err(DownloadError::IoError)?;
        let temp_path = download_path.join("temp");

        // Create directories if they don't exist
        fs::create_dir_all(&download_path).await?;
        fs::create_dir_all(&temp_path).await?;

        Ok(Self {
            download_path,
            temp_path,
            downloader,
        })
    }

    pub async fn download(&self, url: &str) -> Result<(PathBuf, TrackMetadata), DownloadError> {
        let url = Url::parse(url).map_err(|e| DownloadError::InvalidUrl(e.to_string()))?;

        let temp_dir = TempDir::new_in(&self.temp_path)?;

        // Get metadata first
        let metadata = self
            .downloader
            .fetch_metadata(&url, temp_dir.path())
            .await?;
        let final_path = metadata.location.to_path(&self.download_path);

        // Create parent directories if they don't exist
        if let Some(parent) = final_path.parent() {
            fs::create_dir_all(parent).await?;
        }

        // Download directly to final location
        self.downloader
            .download_audio(&url, &final_path, temp_dir.path())
            .await?;

        Ok((final_path, metadata))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    struct TestDownloader;

    #[async_trait::async_trait]
    impl Downloader for TestDownloader {
        async fn check_available(&self) -> Result<(), DownloadError> {
            Ok(())
        }

        async fn fetch_metadata(
            &self,
            _url: &Url,
            _temp_dir: &Path,
        ) -> Result<TrackMetadata, DownloadError> {
            Ok(TrackMetadata {
                location: TrackLocation::new("Test Artist", "Test Song"),
                duration: 180.0,
                source_url: "https://example.com".to_string(),
                download_time: chrono::Utc::now(),
            })
        }

        async fn download_audio(
            &self,
            _url: &Url,
            output: &Path,
            _temp_dir: &Path,
        ) -> Result<(), DownloadError> {
            // Simulate file creation
            if let Some(parent) = output.parent() {
                fs::create_dir_all(parent).await?;
            }
            fs::write(output, b"test data").await?;
            Ok(())
        }
    }

    #[tokio::test]
    async fn test_download_creates_directories() -> Result<(), DownloadError> {
        let temp = tempdir()?;
        let downloader =
            MediaDownloader::new_with_downloader(temp.path(), Arc::new(TestDownloader)).await?;

        let (path, _) = downloader.download("https://example.com/test").await?;

        assert!(path.exists());
        assert!(path.parent().unwrap().exists());

        Ok(())
    }
}

---- components/media_downloader/src/metadata.rs
// components/media_downloader/src/metadata.rs
use crate::organization::TrackLocation;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackMetadata {
    /// Location information (artist, album, title)
    pub location: TrackLocation,
    
    /// Duration in seconds
    pub duration: f64,
    
    /// Original URL the track was downloaded from
    pub source_url: String,
    
    /// When the track was downloaded
    pub download_time: DateTime<Utc>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_metadata_serialization() {
        let location = TrackLocation::new(
            "Test Artist",
            "Test Song",
        );
        
        let metadata = TrackMetadata {
            location,
            duration: 180.5,
            source_url: "https://example.com/song".to_string(),
            download_time: Utc::now(),
        };

        let json = serde_json::to_string(&metadata).unwrap();
        let decoded: TrackMetadata = serde_json::from_str(&json).unwrap();

        assert_eq!(decoded.duration, 180.5);
        assert_eq!(decoded.source_url, "https://example.com/song");
        assert_eq!(decoded.location.artist, "Test Artist");
        assert_eq!(decoded.location.title, "Test Song");
    }

    #[test]
    fn test_metadata_with_album() {
        let location = TrackLocation::with_album(
            "Test Artist",
            "Test Album",
            "Test Song",
        );
        
        let metadata = TrackMetadata {
            location,
            duration: 180.5,
            source_url: "https://example.com/song".to_string(),
            download_time: Utc::now(),
        };

        let json = serde_json::to_string(&metadata).unwrap();
        let decoded: TrackMetadata = serde_json::from_str(&json).unwrap();

        assert_eq!(decoded.location.artist, "Test Artist");
        assert_eq!(decoded.location.album, Some("Test Album".to_string()));
        assert_eq!(decoded.location.title, "Test Song");
    }
}

---- components/media_downloader/src/organization.rs
// components/media_downloader/src/organization.rs
use std::path::{Path, PathBuf};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct TrackLocation {
    pub artist: String,
    pub album: Option<String>,
    pub title: String,
}

impl TrackLocation {
    pub fn new(artist: impl Into<String>, title: impl Into<String>) -> Self {
        Self {
            artist: artist.into(),
            album: None,
            title: title.into(),
        }
    }

    pub fn with_album(
        artist: impl Into<String>,
        album: impl Into<String>,
        title: impl Into<String>,
    ) -> Self {
        Self {
            artist: artist.into(),
            album: Some(album.into()),
            title: title.into(),
        }
    }

    /// Generate a standard file path for the track
    pub fn to_path(&self, library_root: impl AsRef<Path>) -> PathBuf {
        let artist_dir = sanitize_filename::sanitize(&self.artist);
        let title_file = format!("{}.flac", sanitize_filename::sanitize(&self.title));
        
        let mut components = vec![library_root.as_ref().to_path_buf(), PathBuf::from(artist_dir)];
        
        if let Some(album) = &self.album {
            components.push(PathBuf::from(sanitize_filename::sanitize(album)));
        }
        
        components.push(PathBuf::from(title_file));
        components.iter().collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_path_generation_with_album() {
        let location = TrackLocation::with_album(
            "Test Artist",
            "Test Album",
            "Test Song",
        );
        
        let path = location.to_path(Path::new("/music"));
        assert_eq!(
            path,
            Path::new("/music/Test Artist/Test Album/Test Song.flac")
        );
    }

    #[test]
    fn test_path_generation_without_album() {
        let location = TrackLocation::new("Test Artist", "Test Song");
        let path = location.to_path(Path::new("/music"));
        assert_eq!(
            path,
            Path::new("/music/Test Artist/Test Song.flac")
        );
    }

    #[test]
    fn test_sanitization() {
        let location = TrackLocation::with_album(
            "Artist / with / slashes",
            "Album : with : colons",
            "Song * with * stars",
        );
        
        let path = location.to_path(Path::new("/music"));
        assert_eq!(
            path,
            Path::new("/music/Artist  with  slashes/Album  with  colons/Song  with  stars.flac")
        );
    }

    #[test]
    fn test_sanitization_edge_cases() {
        let location = TrackLocation::new(
            "Artist?<>\\/*", 
            "Song|\":\n\t"
        );
        
        let path = location.to_path(Path::new("/music"));
        
        // Get just the filename parts (artist and song)
        let components: Vec<_> = path.components()
            .skip(2) // Skip "/music"
            .map(|c| c.as_os_str().to_string_lossy())
            .collect();
            
        // Should not contain any of these characters
        let forbidden_chars = ['<', '>', '\\', '/', '*', '|', '"', ':', '\n', '\t'];
        
        for component in components {
            for forbidden in forbidden_chars {
                assert!(!component.contains(forbidden), 
                    "Sanitized component '{}' should not contain '{}'", component, forbidden);
            }
        }
    }
}

---- components/media_downloader/src/types.rs
// components/media_downloader/src/types.rs
use crate::organization::TrackLocation;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Debug, Error)]
pub enum DownloadError {
    #[error("Required dependency not found: {0}")]
    DependencyNotFound(&'static str),

    #[error("Invalid URL: {0}")]
    InvalidUrl(String),

    #[error("Download failed: {0}")]
    DownloadFailed(String),

    #[error("Format conversion failed: {0}")]
    FormatError(String),

    #[error("IO error: {0}")]
    IoError(#[from] std::io::Error),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TrackMetadata {
    /// Location information (artist, album, title)
    pub location: TrackLocation,

    /// Duration in seconds
    pub duration: f64,

    /// Original URL the track was downloaded from
    pub source_url: String,

    /// When the track was downloaded
    pub download_time: DateTime<Utc>,
}

#[async_trait::async_trait]
pub trait Downloader {
    /// Check if the downloader is available and has all required dependencies
    async fn check_available(&self) -> Result<(), DownloadError>;

    /// Fetch metadata about a track without downloading it
    async fn fetch_metadata(
        &self,
        url: &url::Url,
        temp_dir: &std::path::Path,
    ) -> Result<TrackMetadata, DownloadError>;

    /// Download a track and convert it to FLAC format
    async fn download_audio(
        &self,
        url: &url::Url,
        output: &std::path::Path,
        temp_dir: &std::path::Path,
    ) -> Result<(), DownloadError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_track_metadata_serialization() {
        let location = TrackLocation::new("Test Artist", "Test Song");

        let metadata = TrackMetadata {
            location,
            duration: 180.5,
            source_url: "https://example.com/song".to_string(),
            download_time: Utc::now(),
        };

        let json = serde_json::to_string(&metadata).unwrap();
        let decoded: TrackMetadata = serde_json::from_str(&json).unwrap();

        assert_eq!(decoded.location.artist, "Test Artist");
        assert_eq!(decoded.location.title, "Test Song");
        assert_eq!(decoded.duration, 180.5);
        assert_eq!(decoded.source_url, "https://example.com/song");
    }

    #[test]
    fn test_download_errors() {
        let io_error = std::io::Error::new(std::io::ErrorKind::NotFound, "file not found");
        let error = DownloadError::IoError(io_error);
        assert!(error.to_string().contains("file not found"));

        let error = DownloadError::DependencyNotFound("yt-dlp");
        assert!(error.to_string().contains("yt-dlp"));

        let error = DownloadError::InvalidUrl("bad://url".to_string());
        assert!(error.to_string().contains("bad://url"));
    }
}

---- components/media_downloader/src/ytdlp.rs
// components/media_downloader/src/ytdlp.rs
use crate::organization::TrackLocation;
use crate::types::{DownloadError, Downloader, TrackMetadata};
use async_trait::async_trait;
use chrono::Utc;
use serde::Deserialize;
use std::path::Path;
use tokio::process::Command;
use url::Url;

#[derive(Debug, Deserialize)]
struct YtDlpMetadata {
    title: String,
    uploader: Option<String>,
    album: Option<String>,
    duration: f64,
    webpage_url: String,
    //usrformat_id: String,
    //ext: String,
    //release_date: Option<String>,
    //track: Option<String>,
    artist: Option<String>,
    creator: Option<String>,
}

pub struct YtDlp;

impl YtDlp {
    /// Verify that ffmpeg is available for format conversion
    async fn check_ffmpeg() -> Result<(), DownloadError> {
        which::which("ffmpeg")
            .map(|_| ())
            .map_err(|_| DownloadError::DependencyNotFound("ffmpeg"))
    }

    /// Select best audio format and ensure FLAC conversion
    fn get_format_args() -> Vec<String> {
        vec![
            // Extract audio only
            "-x".to_string(),
            // Select best audio quality source
            "--format".to_string(),
            "bestaudio".to_string(),
            // Force FLAC output regardless of input
            "--audio-format".to_string(),
            "flac".to_string(),
            // Best quality conversion
            "--audio-quality".to_string(),
            "0".to_string(),
            // Post-process with FFmpeg for reliable conversion
            "--postprocessor-args".to_string(),
            "-acodec flac -compression_level 12".to_string(),
        ]
    }
}

#[async_trait]
impl Downloader for YtDlp {
    async fn check_available(&self) -> Result<(), DownloadError> {
        // Check both yt-dlp and ffmpeg are available
        which::which("yt-dlp").map_err(|_| DownloadError::DependencyNotFound("yt-dlp"))?;
        Self::check_ffmpeg().await?;
        Ok(())
    }

    async fn fetch_metadata(
        &self,
        url: &Url,
        temp_dir: &Path,
    ) -> Result<TrackMetadata, DownloadError> {
        let output = Command::new("yt-dlp")
            .arg("--dump-json")
            .arg("--no-download")
            .arg(url.as_str())
            .current_dir(temp_dir)
            .output()
            .await?;

        if !output.status.success() {
            return Err(DownloadError::DownloadFailed(
                String::from_utf8_lossy(&output.stderr).into_owned(),
            ));
        }

        let yt_meta: YtDlpMetadata = serde_json::from_slice(&output.stdout)
            .map_err(|e| DownloadError::DownloadFailed(e.to_string()))?;

        // Try to determine the artist from various metadata fields
        let artist = yt_meta
            .artist
            .or(yt_meta.creator)
            .or(yt_meta.uploader)
            .unwrap_or_else(|| "Unknown Artist".to_string());

        let location = if let Some(album) = yt_meta.album {
            TrackLocation::with_album(artist, album, yt_meta.title)
        } else {
            TrackLocation::new(artist, yt_meta.title)
        };

        Ok(TrackMetadata {
            location,
            duration: yt_meta.duration,
            source_url: yt_meta.webpage_url,
            download_time: Utc::now(),
        })
    }

    async fn download_audio(
        &self,
        url: &Url,
        output: &Path,
        temp_dir: &Path,
    ) -> Result<(), DownloadError> {
        let mut cmd = Command::new("yt-dlp");

        // Add all format-related arguments
        cmd.args(Self::get_format_args());

        // Add output and URL arguments
        cmd.arg("-o")
            .arg(
                output.to_str().ok_or_else(|| {
                    DownloadError::DownloadFailed("Invalid output path".to_string())
                })?,
            )
            .arg(url.as_str())
            .current_dir(temp_dir);

        let status = cmd.status().await?;

        if !status.success() {
            return Err(DownloadError::DownloadFailed(format!(
                "yt-dlp exited with status: {}",
                status
            )));
        }

        // Verify the output file exists
        if !output.exists() {
            return Err(DownloadError::DownloadFailed(
                "Output file not created".to_string(),
            ));
        }

        Ok(())
    }
}

---- components/playback_engine/Cargo.toml
[package]
name = "playback-engine"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
symphonia = { version = "0.5", features = ["flac"] }
cpal = "0.15"
tokio = { workspace = true, features = ["full"] }
thiserror = { workspace = true }
parking_lot = { workspace = true }
crossbeam = "0.8"
time-primitives = { path = "../time_primitives" }
playback-primitives = { path = "../playback_primitives" }
---- components/playback_engine/src/audio.rs
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};
use cpal::{Device, Stream, StreamConfig};
use crossbeam::channel::{bounded, Sender};
use parking_lot::RwLock;
use std::sync::Arc;
use std::time::Duration;

use crate::error::PlaybackError;

pub struct AudioOutput {
    _stream: Stream,
    _device: Device,
    _config: StreamConfig,
    command_tx: Sender<AudioCommand>,
}

enum AudioCommand {
    AddTrack {
        channel: crate::Channel,
        track: crate::Track,
    },
    RemoveTrack(crate::Channel),
}

type Tracks = Arc<RwLock<Vec<(crate::Channel, Arc<RwLock<crate::Track>>)>>>;

impl AudioOutput {
    pub fn new() -> Result<Self, PlaybackError> {
        let host = cpal::default_host();
        let device = host
            .default_output_device()
            .ok_or_else(|| PlaybackError::AudioDevice("No output device found".into()))?;

        let config = device
            .default_output_config()
            .map_err(|e| PlaybackError::AudioDevice(e.to_string()))?
            .config();

        // Create command channel
        let (command_tx, command_rx) = bounded::<AudioCommand>(32);

        // Create mixing buffer
        let mix_buffer = vec![0f32; config.channels as usize * 1024];
        let mix_buffer = Arc::new(RwLock::new(mix_buffer));

        // Track management
        let tracks: Tracks = Arc::new(RwLock::new(Vec::new()));

        let tracks_ref = Arc::clone(&tracks);
        let mix_buffer_ref = Arc::clone(&mix_buffer);

        // Build audio callback
        let audio_callback = move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
            // Process any pending commands
            while let Ok(cmd) = command_rx.try_recv() {
                let mut tracks = tracks_ref.write();
                match cmd {
                    AudioCommand::AddTrack { channel, track } => {
                        tracks.push((channel, Arc::new(RwLock::new(track))));
                    }
                    AudioCommand::RemoveTrack(channel) => {
                        tracks.retain(|(ch, _)| *ch != channel);
                    }
                }
            }

            // Clear output buffer
            for sample in data.iter_mut() {
                *sample = 0.0;
            }

            // Mix all playing tracks
            let tracks = tracks_ref.read();
            for (_, track) in tracks.iter() {
                let mut track = track.write();
                if track.is_playing() {
                    let mut mix_buffer = mix_buffer_ref.write();
                    if let Ok(len) = track.get_next_samples(&mut mix_buffer) {
                        // Mix into output buffer with volume
                        let volume = track.get_volume();
                        for i in 0..len.min(data.len()) {
                            data[i] += mix_buffer[i] * volume;
                        }
                    }
                }
            }

            // Apply master limiter to prevent clipping
            for sample in data.iter_mut() {
                *sample = sample.clamp(-1.0, 1.0);
            }
        };

        // Error callback
        let error_callback = move |err: cpal::StreamError| {
            eprintln!("Audio stream error: {}", err);
        };

        // Build output stream with buffer duration of 50ms
        let stream = device
            .build_output_stream(
                &config,
                audio_callback,
                error_callback,
                Some(Duration::from_millis(50)),
            )
            .map_err(|e| PlaybackError::AudioDevice(e.to_string()))?;

        // Start the stream
        stream
            .play()
            .map_err(|e| PlaybackError::AudioDevice(e.to_string()))?;

        Ok(Self {
            _stream: stream,
            _device: device,
            _config: config,
            command_tx,
        })
    }

    pub fn add_track(
        &self,
        channel: crate::Channel,
        track: crate::Track,
    ) -> Result<(), PlaybackError> {
        self.command_tx
            .send(AudioCommand::AddTrack { channel, track })
            .map_err(|_| PlaybackError::AudioDevice("Failed to send add track command".into()))
    }

    pub fn remove_track(&self, channel: crate::Channel) -> Result<(), PlaybackError> {
        self.command_tx
            .send(AudioCommand::RemoveTrack(channel))
            .map_err(|_| PlaybackError::AudioDevice("Failed to send remove track command".into()))
    }

    pub fn get_sample_rate(&self) -> u32 {
        self._config.sample_rate.0
    }

    pub fn get_channels(&self) -> u16 {
        self._config.channels
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_audio_output_creation() {
        let audio = AudioOutput::new();
        assert!(audio.is_ok(), "Failed to create audio output");
    }

    #[test]
    fn test_sample_rate_query() {
        if let Ok(audio) = AudioOutput::new() {
            assert!(audio.get_sample_rate() > 0, "Invalid sample rate");
            assert!(audio.get_channels() > 0, "Invalid channel count");
        }
    }
}

---- components/playback_engine/src/error.rs
use thiserror::Error;
use std::path::PathBuf;
use crate::Channel;

#[derive(Error, Debug)]
pub enum PlaybackError {
    #[error("Audio device error: {0}")]
    AudioDevice(String),
    
    #[error("Decoder error: {0}")]
    Decoder(String),
    
    #[error("Track not found: {0}")]
    TrackNotFound(PathBuf),
    
    #[error("Channel {0:?} already in use")]
    ChannelInUse(Channel),
    
    #[error("No track loaded on channel {0:?}")]
    NoTrackLoaded(Channel),
    
    #[error("Invalid volume: {0}dB")]
    InvalidVolume(f32),
    
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
}
---- components/playback_engine/src/lib.rs
mod audio;
mod error;
mod track;

use audio::AudioOutput;
pub use error::PlaybackError;
use std::path::PathBuf;
pub use track::{Channel, Track};

pub struct PlaybackEngine {
    audio: AudioOutput,
}

impl PlaybackEngine {
    pub fn new() -> Result<Self, PlaybackError> {
        let audio = AudioOutput::new()?;

        Ok(Self { audio })
    }

    pub fn load_track(&mut self, path: PathBuf, channel: Channel) -> Result<(), PlaybackError> {
        // Create new track
        let track = Track::new(&path)?;
        self.audio.add_track(channel, track)
    }

    pub fn play(&mut self, _channel: Channel) -> Result<(), PlaybackError> {
        Ok(())
    }

    pub fn stop(&mut self, _channel: Channel) -> Result<(), PlaybackError> {
        Ok(())
    }

    pub fn set_volume(&mut self, _channel: Channel, db: f32) -> Result<(), PlaybackError> {
        if !(-96.0..=0.0).contains(&db) {
            return Err(PlaybackError::InvalidVolume(db));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_load_track_duplicate_channel() {
        let mut engine = PlaybackEngine::new().unwrap();
        let path = PathBuf::from("test.flac");

        // First load should fail because file doesn't exist
        assert!(matches!(
            engine.load_track(path.clone(), Channel::A),
            Err(PlaybackError::TrackNotFound(_))
        ));
    }

    #[test]
    fn test_volume_validation() {
        let mut engine = PlaybackEngine::new().unwrap();

        // Test invalid volume levels
        assert!(matches!(
            engine.set_volume(Channel::A, 1.0),
            Err(PlaybackError::InvalidVolume(_))
        ));

        assert!(matches!(
            engine.set_volume(Channel::A, -100.0),
            Err(PlaybackError::InvalidVolume(_))
        ));
    }
}

---- components/playback_engine/src/track.rs
use parking_lot::RwLock;
use std::path::{Path, PathBuf};
use std::sync::Arc;
use symphonia::core::audio::{Channels, SampleBuffer, SignalSpec};
use symphonia::core::codecs::DecoderOptions;
use symphonia::core::formats::{FormatOptions, FormatReader};
use symphonia::core::io::MediaSourceStream;
use symphonia::core::meta::MetadataOptions;
use symphonia::core::probe::Hint;

use crate::error::PlaybackError;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Channel {
    A,
    B,
}

impl std::fmt::Display for Channel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Channel::A => write!(f, "A"),
            Channel::B => write!(f, "B"),
        }
    }
}

pub struct Track {
    decoder: Arc<RwLock<Box<dyn symphonia::core::codecs::Decoder>>>,
    format: Arc<RwLock<Box<dyn FormatReader>>>,
    buffer: Arc<RwLock<SampleBuffer<f32>>>,
    playing: Arc<RwLock<bool>>,
    volume: Arc<RwLock<f32>>,
}

impl Track {
    pub fn new(path: &Path) -> Result<Self, PlaybackError> {
        if !path.exists() {
            return Err(PlaybackError::TrackNotFound(path.to_owned()));
        }

        // Open media source
        let src = std::fs::File::open(path)?;
        let mss = MediaSourceStream::new(Box::new(src), Default::default());

        // Create probe hint
        let mut hint = Hint::new();
        hint.with_extension("flac");

        // Probe format
        let format_opts = FormatOptions::default();
        let metadata_opts = MetadataOptions::default();
        let probed = symphonia::default::get_probe()
            .format(&hint, mss, &format_opts, &metadata_opts)
            .map_err(|e| PlaybackError::Decoder(e.to_string()))?;

        // Get default track
        let track = probed
            .format
            .default_track()
            .ok_or_else(|| PlaybackError::Decoder("No default track found".into()))?;

        // Get decoder
        let decoder = symphonia::default::get_codecs()
            .make(&track.codec_params, &DecoderOptions::default())
            .map_err(|e| PlaybackError::Decoder(e.to_string()))?;

        // Create sample buffer with proper signal spec
        let spec = SignalSpec::new(
            track.codec_params.sample_rate.unwrap_or(44100),
            track
                .codec_params
                .channels
                .unwrap_or(Channels::FRONT_LEFT | Channels::FRONT_RIGHT),
        );

        Ok(Self {
            decoder: Arc::new(RwLock::new(decoder)), // decoder is already a Box<dyn Decoder>
            format: Arc::new(RwLock::new(probed.format)),
            buffer: Arc::new(RwLock::new(SampleBuffer::new(1024, spec))),
            playing: Arc::new(RwLock::new(false)),
            volume: Arc::new(RwLock::new(1.0)),
        })
    }

    pub fn play(&mut self) {
        *self.playing.write() = true;
    }

    pub fn stop(&mut self) {
        *self.playing.write() = false;
    }

    pub fn is_playing(&self) -> bool {
        *self.playing.read()
    }

    pub fn set_volume(&mut self, db: f32) {
        // Convert dB to linear amplitude
        let linear = 10.0f32.powf(db / 20.0);
        *self.volume.write() = linear;
    }

    pub fn get_volume(&self) -> f32 {
        *self.volume.read()
    }

    pub fn get_next_samples(&mut self, buffer: &mut [f32]) -> Result<usize, PlaybackError> {
        if !self.is_playing() {
            return Ok(0);
        }

        let mut format = self.format.write();
        let mut decoder = self.decoder.write();
        let mut sample_buf = self.buffer.write();
        let volume = self.get_volume();

        let packet = format
            .next_packet()
            .map_err(|e| PlaybackError::Decoder(e.to_string()))?;

        let decoded = decoder
            .decode(&packet)
            .map_err(|e| PlaybackError::Decoder(e.to_string()))?;

        sample_buf.copy_interleaved_ref(decoded);
        let samples = sample_buf.samples();
        let len = std::cmp::min(buffer.len(), samples.len());

        for i in 0..len {
            buffer[i] = samples[i] * volume;
        }

        Ok(len)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn test_track_volume() {
        let path = PathBuf::from("test.flac");
        assert!(Track::new(&path).is_err()); // Should fail as file doesn't exist
    }
}

---- components/playback_primitives/Cargo.toml
[package]
name = "playback-primitives"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
thiserror.workspace = true
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
assert_matches.workspace = true
serde_json = "1.0"

---- components/playback_primitives/src/lib.rs
use thiserror::Error;
use serde::{Serialize, Deserialize};

#[derive(Debug, Error)]
pub enum PlaybackError {
    #[error("Invalid channel number")]
    InvalidChannel,
    #[error("Value out of range")]
    ValueOutOfRange,
}

/// Common behavior for decibel-based measurements
pub trait Db {
    fn to_linear(&self) -> f32;
    fn raw(&self) -> f32;
}

/// Volume level in dBFS (decibels full scale)
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct Volume(f32);

impl Volume {
    const MIN_DB: f32 = -96.0;
    const MAX_DB: f32 = 0.0;  // dBFS can't go above 0
    
    pub const SILENT: Self = Self(-96.0);
    pub const UNITY: Self = Self(0.0);
    
    pub fn new(dbfs: f32) -> Result<Self, PlaybackError> {
        if (Self::MIN_DB..=Self::MAX_DB).contains(&dbfs) {
            Ok(Self(dbfs))
        } else {
            Err(PlaybackError::ValueOutOfRange)
        }
    }
}

impl Db for Volume {
    fn to_linear(&self) -> f32 {
        10.0f32.powf(self.0 / 20.0)
    }

    fn raw(&self) -> f32 {
        self.0
    }
}

/// Identifies a playback channel (deck)
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct Channel(u8);

impl Channel {
    pub const CHANNEL_A: Self = Self(0);
    pub const CHANNEL_B: Self = Self(1);
    
    pub fn new(channel: u8) -> Result<Self, PlaybackError> {
        match channel {
            0 | 1 => Ok(Self(channel)),
            _ => Err(PlaybackError::InvalidChannel)
        }
    }

    pub fn raw(&self) -> u8 {
        self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    mod volume_tests {
        use super::*;

        #[test]
        fn unity_is_linear_one() {
            assert_eq!(Volume::UNITY.to_linear(), 1.0);
        }
        
        #[test]
        fn silent_is_near_zero() {
            assert!(Volume::SILENT.to_linear() < 0.0001);
        }

        #[test]
        fn converts_common_values() {
            let test_points: [(f32, f32); 3] = [
                (0.0, 1.0),      // 0 dBFS = 1.0
                (-6.0, 0.501),   // -6 dBFS  0.501
                (-20.0, 0.1),    // -20 dBFS = 0.1
            ];

            for (db, expected) in test_points {
                let vol = Volume::new(db).unwrap();
                let actual = vol.to_linear();
                
                let tolerance = expected * 0.001; // 0.1% tolerance
                assert!((actual - expected).abs() <= tolerance, 
                        "For {}dBFS: expected {}, got {}", db, expected, actual);
            }
        }

        #[test]
        fn rejects_positive_dbfs() {
            assert!(matches!(Volume::new(1.0), Err(PlaybackError::ValueOutOfRange)));
        }

        #[test]
        fn test_serialization() {
            let vol = Volume::new(-6.0).unwrap();
            let json = serde_json::to_string(&vol).unwrap();
            let decoded: Volume = serde_json::from_str(&json).unwrap();
            assert_eq!(vol, decoded);
        }
    }

    mod channel_tests {
        use super::*;

        #[test]
        fn creates_channel_a() {
            assert!(matches!(Channel::new(0), Ok(Channel::CHANNEL_A)));
        }

        #[test]
        fn creates_channel_b() {
            assert!(matches!(Channel::new(1), Ok(Channel::CHANNEL_B)));
        }

        #[test]
        fn rejects_invalid_channel() {
            assert!(matches!(Channel::new(2), Err(PlaybackError::InvalidChannel)));
        }

        #[test]
        fn test_serialization() {
            let channel = Channel::CHANNEL_A;
            let json = serde_json::to_string(&channel).unwrap();
            let decoded: Channel = serde_json::from_str(&json).unwrap();
            assert_eq!(channel, decoded);
        }
    }
}
---- components/time_primitives/Cargo.toml
[package]
name = "time-primitives"
version.workspace = true
edition.workspace = true
authors.workspace = true
repository.workspace = true
license.workspace = true

[dependencies]
thiserror.workspace = true
serde = { version = "1.0", features = ["derive"] }

[dev-dependencies]
assert_matches.workspace = true
serde_json = "1.0"
---- components/time_primitives/src/lib.rs
use std::ops::{Add, Sub};
use thiserror::Error;
use serde::{Serialize, Deserialize};

#[derive(Debug, Error)]
pub enum TimeError {
    #[error("PPQN cannot be zero")]
    ZeroPpqn,
    #[error("Tempo must be between {min} and {max} BPM")]
    TempoOutOfRange { min: f64, max: f64, value: f64 },
}

/// Number of ticks in the musical timeline
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub struct Ticks(u64);

impl Ticks {
    pub const ZERO: Self = Self(0);

    pub fn new(ticks: u64) -> Self {
        Self(ticks)
    }

    pub fn raw(&self) -> u64 {
        self.0
    }
}

impl Add for Ticks {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        Self(self.0 + other.0)
    }
}

impl Sub for Ticks {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        Self(self.0.saturating_sub(other.0))
    }
}

/// Pulses per quarter note - resolution of the musical timeline
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub struct Ppqn(u32);

impl Ppqn {
    pub const DEFAULT: Self = Self(960);

    pub fn new(ppqn: u32) -> Result<Self, TimeError> {
        if ppqn == 0 {
            return Err(TimeError::ZeroPpqn);
        }
        Ok(Self(ppqn))
    }

    pub fn raw(&self) -> u32 {
        self.0
    }
}

/// Tempo in beats per minute
#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize)]
pub struct Tempo(f64);

impl Tempo {
    pub const MIN: f64 = 20.0;
    pub const MAX: f64 = 400.0;
    pub const DEFAULT: Self = Self(120.0);

    pub fn new(bpm: f64) -> Result<Self, TimeError> {
        if !(Self::MIN..=Self::MAX).contains(&bpm) {
            return Err(TimeError::TempoOutOfRange { 
                min: Self::MIN,
                max: Self::MAX,
                value: bpm,
            });
        }
        Ok(Self(bpm))
    }

    pub fn raw(&self) -> f64 {
        self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ticks_operations() {
        let t1 = Ticks::new(100);
        let t2 = Ticks::new(50);

        assert_eq!(t1 + t2, Ticks::new(150));
        assert_eq!(t1 - t2, Ticks::new(50));
        assert_eq!(t2 - t1, Ticks::ZERO); // Tests saturation
    }

    #[test]
    fn test_ppqn_validation() {
        assert!(matches!(
            Ppqn::new(0).unwrap_err(),
            TimeError::ZeroPpqn
        ));
        assert!(Ppqn::new(960).is_ok());
        assert_eq!(Ppqn::DEFAULT.raw(), 960);
    }

    #[test]
    fn test_tempo_validation() {
        assert!(matches!(
            Tempo::new(0.0).unwrap_err(),
            TimeError::TempoOutOfRange { min: 20.0, max: 400.0, value: 0.0 }
        ));
        assert!(matches!(
            Tempo::new(500.0).unwrap_err(),
            TimeError::TempoOutOfRange { min: 20.0, max: 400.0, value: 500.0 }
        ));
        assert!(Tempo::new(120.0).is_ok());
        assert_eq!(Tempo::DEFAULT.raw(), 120.0);
    }

    #[test]
    fn test_serialization() {
        let ticks = Ticks::new(42);
        let json = serde_json::to_string(&ticks).unwrap();
        let decoded: Ticks = serde_json::from_str(&json).unwrap();
        assert_eq!(ticks, decoded);

        let tempo = Tempo::new(140.0).unwrap();
        let json = serde_json::to_string(&tempo).unwrap();
        let decoded: Tempo = serde_json::from_str(&json).unwrap();
        assert_eq!(tempo, decoded);
    }
}
